<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Nick Huntington-Klein, Philip Khor" />

<meta name="date" content="2019-08-20" />

<title>pmdplyr: Panel Tools</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">pmdplyr: Panel Tools</h1>
<h4 class="author">Nick Huntington-Klein, Philip Khor</h4>
<h4 class="date">2019-08-20</h4>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(pmdplyr)</span></code></pre></div>
<p>The <code>pmdplyr</code> package is an extension to <code>dplyr</code> designed for cleaning and managing panel and hierarchical data. It contains variations on the <code>dplyr::mutate()</code> and <code>dplyr::join()</code> functions that address common panel data needs, and contains functions for managing and cleaning panel data.</p>
<p>Unlike other panel data packages, functions in <code>pmdplyr</code> are all designed to work even if there is more than one observation per individual per period. This comes in handy if each individual is observed multiple times per period - for example, multiple classes per student per term; or if you have hierarchical data - for example, multiple companies per country.</p>
<p>There are three vignettes in total describing the contents of <code>pmdplyr</code>:</p>
<ol style="list-style-type: decimal">
<li><p>“pmdplyr”/“Get Started”, which describes the <code>pibble</code> panel data object type, and the <code>pmdplyr</code> tools for creating well-behaved ID and time variables <code>id_variable()</code> and <code>time_variable()</code>.</p></li>
<li><p>“dplyr variants”, which that describes <code>pmdplyr</code> variations on <code>dplyr</code> functions <code>mutate()</code> (<code>mutate_cascade()</code> and <code>mutate_subset()</code>), <code>_join</code> (<code>inexact_join</code> and <code>safe_join()</code>), and <code>lag</code> (<code>tlag()</code>).</p></li>
<li><p><strong>CURRENT VIGNETTE</strong> “Panel Tools”, which describes novel tools that <code>pmdplyr</code> provides for cleaning and manipulating panel data (<code>panel_fill()</code>, <code>panel_locf()</code>, <code>fixed_check()</code>, <code>fixed_force()</code>, <code>between_i()</code>, <code>within_i()</code>, <code>mode_order()</code>).</p></li>
</ol>
<hr />
<div id="filling-in-data" class="section level1">
<h1>Filling in Data</h1>
<p>In a panel data context, missing data can be categorized into two kinds: explicit missing values for certain observations (<code>NA</code>s), or observations that are missing entirely - for example if person <code>1</code> has observations in period <code>1</code> and period <code>3</code>, but not period <code>2</code>.</p>
<p>You may wish to fill in either of these kinds of missing data using the data you do have.</p>
<div id="panel_fill" class="section level2">
<h2>panel_fill()</h2>
<p><code>panel_fill()</code> will fill in gaps between time periods for individuals. For example, if person <code>1</code> has observations in period <code>1</code> and period <code>3</code>, but not period <code>2</code>, then <code>panel_fill()</code> will add an observation to the data for person <code>1</code> in time period <code>2</code>. If there is more than one observation for person <code>1</code> in period <code>1</code>, then all of them will be copied for period <code>2</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">panel_fill</span>(.df,</span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="dt">.set_NA =</span> <span class="ot">FALSE</span>,</span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="dt">.min =</span> <span class="ot">NA</span>,</span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="dt">.max =</span> <span class="ot">NA</span>,</span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="dt">.backwards =</span> <span class="ot">FALSE</span>,</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="dt">.group_i =</span> <span class="ot">TRUE</span>,</span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="dt">.flag =</span> <span class="ot">NA</span>,</span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="dt">.i =</span> <span class="ot">NULL</span>,</span>
<span id="cb2-9"><a href="#cb2-9"></a>  <span class="dt">.t =</span> <span class="ot">NULL</span>,</span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="dt">.d =</span> <span class="dv">1</span>,</span>
<span id="cb2-11"><a href="#cb2-11"></a>  <span class="dt">.uniqcheck =</span> <span class="ot">FALSE</span>,</span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="dt">.setpanel =</span> <span class="ot">TRUE</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>)</span></code></pre></div>
<p><code>panel_fill()</code> will give us some newly-created observations, and we need to decide what to fill them in with. By default, it will fill in values using what we see in the most recent non-missing observation. But we can set <code>.backwards = TRUE</code> to use the <em>next</em> non-missing observation instead, or use <code>.set_NA</code> to fill the new observations with <code>NA</code>.</p>
<p><code>.set_NA</code> is a character vector of variable names that should be set to <code>NA</code> for newly-created observations, or set to <code>TRUE</code> to set everything except <code>.i</code> and <code>.t</code> to <code>NA</code>. You can also create a new variable indicating which observations are newly-created with <code>.flag</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Note the gap between periods 2 and 4 for person 1.</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>,</span>
<span id="cb3-6"><a href="#cb3-6"></a>  <span class="dt">y =</span> <span class="dv">7</span><span class="op">:</span><span class="dv">12</span>,</span>
<span id="cb3-7"><a href="#cb3-7"></a>  <span class="dt">.i =</span> i,</span>
<span id="cb3-8"><a href="#cb3-8"></a>  <span class="dt">.t =</span> t</span>
<span id="cb3-9"><a href="#cb3-9"></a>)</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="kw">panel_fill</span>(df, <span class="dt">.set_NA =</span> <span class="st">&quot;y&quot;</span>, <span class="dt">.flag =</span> <span class="st">&quot;new_obs&quot;</span>)</span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">#&gt; # A pibble: 7 x 5</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">#&gt; # Gap (.d): 1</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#&gt;       i     t     x     y new_obs</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt;  </span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">#&gt; 1     1     2     1     7 FALSE  </span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">#&gt; 2     1     3     1    NA TRUE   </span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="co">#&gt; 3     1     4     2     8 FALSE  </span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">#&gt; 4     1     5     3     9 FALSE  </span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="co">#&gt; 5     2     1     4    10 FALSE  </span></span>
<span id="cb3-21"><a href="#cb3-21"></a><span class="co">#&gt; 6     2     2     5    11 FALSE  </span></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="co">#&gt; 7     2     3     6    12 FALSE</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="kw">panel_fill</span>(df, <span class="dt">.set_NA =</span> <span class="st">&quot;y&quot;</span>, <span class="dt">.backwards =</span> <span class="ot">TRUE</span>)<span class="op">$</span>x</span>
<span id="cb3-24"><a href="#cb3-24"></a><span class="co">#&gt; [1] 1 2 2 3 4 5 6</span></span></code></pre></div>
<p>By default, <code>panel_fill()</code> will only fill in gaps between existing observations. However, commonly we might want to create new observations outside of the existing range, perhaps to create a fully balanced panel for ourselves. <code>.min</code> and <code>.max</code> will ensure that each individual has observations at least as far back as <code>.min</code>, and at least as far out as <code>.max</code>. Set <code>.min = min(t)</code> and <code>.max = max(t)</code> (where <code>t</code> is your time variable) to ensure a fully balanced panel.</p>
<p>Data for the outside-the-observed-range values will be taken from the closest observed value.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">panel_fill</span>(df, <span class="dt">.min =</span> <span class="kw">min</span>(df<span class="op">$</span>t), <span class="dt">.max =</span> <span class="kw">max</span>(df<span class="op">$</span>t))</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co">#&gt; # A pibble: 10 x 4</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">#&gt; # Gap (.d): 1</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">#&gt;        i     t     x     y</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#&gt;  1     1     1     1     7</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">#&gt;  2     1     2     1     7</span></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">#&gt;  3     1     3     1     7</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">#&gt;  4     1     4     2     8</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">#&gt;  5     1     5     3     9</span></span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">#&gt;  6     2     1     4    10</span></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="co">#&gt;  7     2     2     5    11</span></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">#&gt;  8     2     3     6    12</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="co">#&gt;  9     2     4     6    12</span></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="co">#&gt; 10     2     5     6    12</span></span></code></pre></div>
<p>The rest of the options include <code>.group_i</code> (by default, if <code>.i</code> can be found, data will be filled within-individual. Set <code>.group_i = FALSE</code> to ignore this), and standard arguments related to declaring the panel structure of the data (<code>.i</code>, <code>.t</code>, <code>.d</code>, <code>.uniqcheck</code>, see the “pibble” section above). <code>.setpanel</code> ensures that if you declare the panel structure in the <code>panel_fill()</code> function, it will be maintained in the object you get back.</p>
</div>
<div id="panel_locf" class="section level2">
<h2>panel_locf()</h2>
<p><code>panel_locf()</code> (“last observation carried forward”) will fill in explicit <code>NA</code> values using recently available data. It is very similar to <code>zoo::na.locf()</code> except that it respects panel structure and is more flexible.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">panel_locf</span>(.var,</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="dt">.df =</span> <span class="kw">get</span>(<span class="st">&quot;.&quot;</span>, <span class="dt">envir =</span> <span class="kw">parent.frame</span>()),</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="dt">.fill =</span> <span class="ot">NA</span>,</span>
<span id="cb5-4"><a href="#cb5-4"></a>  <span class="dt">.backwards =</span> <span class="ot">FALSE</span>,</span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="dt">.resolve =</span> <span class="st">&quot;error&quot;</span>,</span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span class="dt">.group_i =</span> <span class="ot">TRUE</span>,</span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="dt">.i =</span> <span class="ot">NULL</span>,</span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="dt">.t =</span> <span class="ot">NULL</span>,</span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="dt">.d =</span> <span class="dv">1</span>,</span>
<span id="cb5-10"><a href="#cb5-10"></a>  <span class="dt">.uniqcheck =</span> <span class="ot">FALSE</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>)</span></code></pre></div>
<p>where <code>.var</code> is the variable to be filled in, and <code>.df</code> is the data set that variable lives in. If the data set is being passed in via <code>%&gt;% mutate()</code> or similar, then <code>.df</code> will automatically pick it up and you don’t need to specify it.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>),</span>
<span id="cb6-4"><a href="#cb6-4"></a>  <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>, <span class="dv">3</span>, <span class="ot">NA</span>, <span class="dv">-3</span>, <span class="dv">4</span>),</span>
<span id="cb6-5"><a href="#cb6-5"></a>  <span class="dt">.i =</span> i,</span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="dt">.t =</span> t</span>
<span id="cb6-7"><a href="#cb6-7"></a>)</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co"># Notice that the fourth observation doesn&#39;t get filled in</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="co"># because it&#39;s the first observation for person 2, so nothing to fill in from</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>df <span class="op">%&gt;%</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">x_filled =</span> <span class="kw">panel_locf</span>(x))</span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">#&gt; # A pibble:                         6 x 4</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">#&gt; # Individual-level identifier (.i): i [2]</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">#&gt; # Time variable (.t):               t [4]</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">#&gt; # Gap (.d):                         1</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="co">#&gt;       i     t     x x_filled</span></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;</span></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="co">#&gt; 1     1     1     1        1</span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="co">#&gt; 2     1     2    NA        1</span></span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="co">#&gt; 3     1     3     3        3</span></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="co">#&gt; 4     2     2    NA       NA</span></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="co">#&gt; 5     2     3    -3       -3</span></span>
<span id="cb6-24"><a href="#cb6-24"></a><span class="co">#&gt; 6     2     4     4        4</span></span></code></pre></div>
<p>You have a fair amount of control over how filling-in works. By default, data will be filled in using the most recent previous observation. But <code>.backwards = TRUE</code> will use the <em>next upcoming</em> observation instead. Also, by default, only <code>NA</code> values will be overwritten. But <code>.fill</code> will allow you to specify a vector of values (perhaps including <code>NA</code>) to be overwritten. This can be handy if you’re working with data that uses missingness indicators other than <code>NA</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(</span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="dt">x_filled =</span> <span class="kw">panel_locf</span>(x, <span class="dt">.backwards =</span> <span class="ot">TRUE</span>),</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="dt">x_no_neg3 =</span> <span class="kw">panel_locf</span>(x, <span class="dt">.backwards =</span> <span class="ot">TRUE</span>, <span class="dt">.fill =</span> <span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">-3</span>))</span>
<span id="cb7-4"><a href="#cb7-4"></a>)</span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">#&gt; # A pibble:                         6 x 5</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">#&gt; # Individual-level identifier (.i): i [2]</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="co">#&gt; # Time variable (.t):               t [4]</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="co">#&gt; # Gap (.d):                         1</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="co">#&gt;       i     t     x x_filled x_no_neg3</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="co">#&gt; 1     1     1     1        1         1</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="co">#&gt; 2     1     2    NA        3         3</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="co">#&gt; 3     1     3     3        3         3</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="co">#&gt; 4     2     2    NA       -3         4</span></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="co">#&gt; 5     2     3    -3       -3         4</span></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="co">#&gt; 6     2     4     4        4         4</span></span></code></pre></div>
<p><code>panel_locf()</code> will work even if <code>.i</code> and <code>.t</code> don’t uniquely identify the observations. However, this presents a problem! If there are <em>different values</em> of <code>.var</code> for a given combination of <code>.i</code> and <code>.t</code>, then which value do we choose to use for the purpose of filling in other observations? <code>.resolve</code> makes this choice. By default, there will be an “error” if values of <code>.var</code> are inconsistent within <code>.i</code> and <code>.t</code>. Or, set <code>.resolve</code> to a summary function like <code>.resolve = mean</code> or <code>.resolve = function(x) mean(x, na.rm = TRUE)</code> to resolve inconsistencies before filling in. If you have some <code>.i</code>/<code>.t</code> combinations with both missing and non-missing values, the missing values will be filled in using the same function.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>inconsistent_df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</span>
<span id="cb8-2"><a href="#cb8-2"></a>  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="ot">NA</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="dt">.i =</span> i,</span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="dt">.t =</span> t</span>
<span id="cb8-7"><a href="#cb8-7"></a>)</span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a>inconsistent_df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(</span>
<span id="cb8-10"><a href="#cb8-10"></a>  <span class="dt">x_filled =</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="kw">panel_locf</span>(x, <span class="dt">.resolve =</span> mean)</span>
<span id="cb8-12"><a href="#cb8-12"></a>)</span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="co">#&gt; # A pibble:                         6 x 4</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="co">#&gt; # Individual-level identifier (.i): i [2]</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="co">#&gt; # Time variable (.t):               t [3]</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="co">#&gt; # Gap (.d):                         1</span></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="co">#&gt;       i     t     x x_filled</span></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="co">#&gt; 1     1     1     1      1  </span></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="co">#&gt; 2     1     1     2      2  </span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="co">#&gt; 3     1     2    NA      1.5</span></span>
<span id="cb8-22"><a href="#cb8-22"></a><span class="co">#&gt; 4     2     1     1      1  </span></span>
<span id="cb8-23"><a href="#cb8-23"></a><span class="co">#&gt; 5     2     2     2      2  </span></span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="co">#&gt; 6     2     3     3      3</span></span></code></pre></div>
<p>The rest of the options include <code>.group_i</code> (by default, if <code>.i</code> can be found, data will be filled within-individual. Set <code>.group_i = FALSE</code> to ignore this), and standard arguments related to declaring the panel structure of the data (<code>.i</code>, <code>.t</code>, <code>.d</code>, <code>.uniqcheck</code>, see the “pibble” section above).</p>
<hr />
</div>
</div>
<div id="panel-consistency" class="section level1">
<h1>Panel Consistency</h1>
<p>In panel data, and especially hierarchical data, there are some variables that should be <em>fixed</em> within values of other variables. And if they’re not, you have a problem!</p>
<p>For example, consider the data set</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb9-2"><a href="#cb9-2"></a>  <span class="dt">continent =</span> <span class="kw">c</span>(<span class="st">&quot;Asia&quot;</span>, <span class="st">&quot;Europe&quot;</span>, <span class="st">&quot;Europe&quot;</span>, <span class="st">&quot;S America&quot;</span>, <span class="st">&quot;S America&quot;</span>),</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="dt">country =</span> <span class="kw">c</span>(<span class="st">&quot;France&quot;</span>, <span class="st">&quot;France&quot;</span>, <span class="st">&quot;France&quot;</span>, <span class="st">&quot;Brazil&quot;</span>, <span class="st">&quot;Brazil&quot;</span>),</span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="dt">year =</span> <span class="kw">c</span>(<span class="dv">2000</span>, <span class="dv">2001</span>, <span class="dv">2002</span>, <span class="dv">2000</span>, <span class="dv">2001</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a>)</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a>df</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="co">#&gt;   continent country year</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="co">#&gt; 1      Asia  France 2000</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="co">#&gt; 2    Europe  France 2001</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co">#&gt; 3    Europe  France 2002</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="co">#&gt; 4 S America  Brazil 2000</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="co">#&gt; 5 S America  Brazil 2001</span></span></code></pre></div>
<p>The variable <code>continent</code> should never change within values of <code>country</code> - a country can’t change the continent it’s on! The fact that France changes continents from year to year in this data should be regarded as very fishy. It will be handy to spot these sorts of potential errors in your data set, and fix them if you think you know how.</p>
<div id="fixed_check" class="section level2">
<h2>fixed_check()</h2>
<p><code>fixed_check()</code> will look in your data <code>.df</code> for inconsistencies in the value of some variables <code>.var</code> within values of other variables <code>.within</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">fixed_check</span>(.df,</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="dt">.var =</span> <span class="ot">NULL</span>,</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="dt">.within =</span> <span class="ot">NULL</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>)</span></code></pre></div>
<p>You should pick variables for <code>.var</code> that are supposed to be constant within combinations of <code>.within</code>.</p>
<p>If your data has problems and is inconsistent, <code>fixed_check()</code> will retun a list of data sets, one for each <code>.var</code> variable, containing the subset of the data that gives you problems. For our <code>df</code> with the France problem, that’s all of the France observations!</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">fixed_check</span>(df, <span class="dt">.var =</span> continent, <span class="dt">.within =</span> country)<span class="op">$</span>continent</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co">#&gt; # A tibble: 3 x 3</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co">#&gt;   continent country  year</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co">#&gt;   &lt;fct&gt;     &lt;fct&gt;   &lt;dbl&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co">#&gt; 1 Asia      France   2000</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co">#&gt; 2 Europe    France   2001</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co">#&gt; 3 Europe    France   2002</span></span></code></pre></div>
<p>If your data is fine, and all <code>.var</code> variables are indeed constant within combinations of <code>.within</code>, then <code>fixed_check()</code> will return <code>TRUE</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>consistent_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="dt">state =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="dt">year =</span> <span class="kw">c</span>(<span class="dv">2000</span>, <span class="dv">2001</span>, <span class="dv">2001</span>, <span class="dv">2000</span>, <span class="dv">2000</span>, <span class="dv">2001</span>),</span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="dt">treatment =</span> <span class="kw">c</span>(F, T, T, T, T, F),</span>
<span id="cb12-5"><a href="#cb12-5"></a>  <span class="dt">outcome =</span> <span class="kw">c</span>(<span class="fl">4.4</span>, <span class="fl">3.2</span>, <span class="fl">3.4</span>, <span class="fl">5.5</span>, <span class="fl">5.6</span>, <span class="dv">8</span>)</span>
<span id="cb12-6"><a href="#cb12-6"></a>)</span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="co"># Since this policy treatment is administered on the state level,</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="co"># everyone in the same state/year should get the same treatment.</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co"># And they do!</span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="kw">fixed_check</span>(consistent_df, <span class="dt">.var =</span> treatment, <span class="dt">.within =</span> <span class="kw">c</span>(state, year))</span>
<span id="cb12-12"><a href="#cb12-12"></a><span class="co">#&gt; [1] TRUE</span></span></code></pre></div>
<p>Some handy <code>fixed_check()</code> tips:</p>
<ol style="list-style-type: decimal">
<li><code>fixed_check()</code> returns either a <code>logical</code> or a <code>list</code> depending on the outcome. If you want to just get <code>FALSE</code> instead of a list of data sets, do <code>is.logical(fixed_check())</code> instead of <code>fixed_check()</code>.</li>
<li>If you do have problems and want a consistent data set, you can fix things by hand as you like, or you can use <code>fixed_force()</code> (see below) to change the observations to be consistent, or to drop all inconsistent observations with <code>fixed_force(.resolve = &quot;drop&quot;)</code>.</li>
</ol>
</div>
<div id="fixed_force" class="section level2">
<h2>fixed_force()</h2>
<p><code>fixed_force()</code> will take a data set <code>.df</code>, find any inconsistencies in the variables <code>.var</code> within combinations of the variables <code>.within</code>, and will “fix” those inconsistencies, using the function <code>.resolve</code> to select the correct values. It can flag any changed values with a new variable named <code>.flag</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">fixed_force</span>(..df,</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="dt">.var =</span> <span class="ot">NULL</span>,</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="dt">.within =</span> <span class="ot">NULL</span>,</span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="dt">.resolve =</span> mode_order,</span>
<span id="cb13-5"><a href="#cb13-5"></a>  <span class="dt">.flag =</span> <span class="ot">NA</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>)</span></code></pre></div>
<p>The default resolution function is <code>mode_order()</code> (see the Additional Calculations section), which calculates the mode, selecting the first-ordered value in the data if there are ties. The mode seems most relevant here, since the most likely (and responsible) use for <code>fixed_force()</code> is when you have data that is mostly correct but just has a few odd values that are likely just miscodes. <code>mode_order()</code> also is not just limited to numeric variables.</p>
<p>Continuing with our France-in-Asia data set,</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">fixed_force</span>(df, <span class="dt">.var =</span> continent, <span class="dt">.within =</span> country, <span class="dt">.flag =</span> <span class="st">&quot;altered&quot;</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co">#&gt; # A tibble: 5 x 4</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co">#&gt;   continent country  year altered</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="co">#&gt;   &lt;fct&gt;     &lt;fct&gt;   &lt;dbl&gt; &lt;lgl&gt;  </span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="co">#&gt; 1 Europe    France   2000 TRUE   </span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="co">#&gt; 2 Europe    France   2001 FALSE  </span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="co">#&gt; 3 Europe    France   2002 FALSE  </span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="co">#&gt; 4 S America Brazil   2000 FALSE  </span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="co">#&gt; 5 S America Brazil   2001 FALSE</span></span></code></pre></div>
<p>Another option for <code>.resolve</code> is to set <code>.resolve = &quot;drop&quot;</code> (or any other character, really), and it will drop the inconsistent observations.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">fixed_force</span>(df, <span class="dt">.var =</span> continent, <span class="dt">.within =</span> country, <span class="dt">.resolve =</span> <span class="st">&quot;drop&quot;</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="co">#&gt; # A tibble: 2 x 3</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">#&gt;   continent country  year</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co">#&gt;   &lt;fct&gt;     &lt;fct&gt;   &lt;dbl&gt;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co">#&gt; 1 S America Brazil   2000</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co">#&gt; 2 S America Brazil   2001</span></span></code></pre></div>
<hr />
</div>
</div>
<div id="additional-calculations" class="section level1">
<h1>Additional Calculations</h1>
<p><code>pmdplyr</code> contains several additional functions that produce calculations of interest.</p>
<div id="between_i" class="section level2">
<h2>between_i()</h2>
<p><code>between_i()</code> performs the <em>between transformation</em>. In particular, it isolates the variation between <code>.i</code> groups in a variable <code>.var</code>, throwing out all variation within <code>.i</code> groups. The result is identical within combinations of <code>.i</code>.</p>
<p>The specific calculation that is performed is</p>
<p><span class="math display">\[between.i(x) = \bar{x}_i - \bar{x}\]</span></p>
<p>where <span class="math inline">\(\bar{x}_i\)</span> is the mean of <code>x</code> within the <code>.i</code> groups, and <span class="math inline">\(\bar{x}\)</span> is the grand mean of <code>x</code> over all observations.</p>
<p>Be aware that this is different from <code>plm::between()</code>, which returns <span class="math inline">\(\bar{x}_i\)</span> and does not subtract out <span class="math inline">\(\bar{x}\)</span>.</p>
<p>The syntax for <code>between_i()</code> is:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">between_i</span>(.var,</span>
<span id="cb16-2"><a href="#cb16-2"></a>  <span class="dt">.df =</span> <span class="kw">get</span>(<span class="st">&quot;.&quot;</span>, <span class="dt">envir =</span> <span class="kw">parent.frame</span>()),</span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span class="dt">.fcn =</span> <span class="cf">function</span>(x) <span class="kw">mean</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</span>
<span id="cb16-4"><a href="#cb16-4"></a>  <span class="dt">.i =</span> <span class="ot">NULL</span>,</span>
<span id="cb16-5"><a href="#cb16-5"></a>  <span class="dt">.t =</span> <span class="ot">NULL</span>,</span>
<span id="cb16-6"><a href="#cb16-6"></a>  <span class="dt">uniqcheck =</span> <span class="ot">FALSE</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>)</span></code></pre></div>
<p>Where <code>.var</code> is the variable on which the transformation is performed, and <code>.df</code> is the data set. If the data set is being passed in via <code>%&gt;% mutate()</code> or similar, then <code>.df</code> will automatically pick it up and you don’t need to specify it. <code>.fcn</code> is the function applied to calculate the group and grand values, i.e. <span class="math inline">\(.fcn(x) = \bar{x}\)</span>. The standard definition of the between transformation is for this to be the mean, but it has been left flexible.</p>
<p>The rest of the options include standard arguments related to declaring the panel structure of the data (<code>.i</code>, <code>.t</code>, <code>.uniqcheck</code>, see the “pibble” section above). <code>.d</code> is omitted because it is irrelevant to the calculation.</p>
<p>An example of the between transformation follows:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>),</span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>,</span>
<span id="cb17-4"><a href="#cb17-4"></a>  <span class="dt">.i =</span> i</span>
<span id="cb17-5"><a href="#cb17-5"></a>) <span class="op">%&gt;%</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">between_x =</span> <span class="kw">between_i</span>(x))</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="co"># Notice that the grand mean is...</span></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="kw">mean</span>(df<span class="op">$</span>x)</span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="co">#&gt; [1] 2.5</span></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="co"># And the mean within groups is...</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>df <span class="op">%&gt;%</span></span>
<span id="cb17-13"><a href="#cb17-13"></a><span class="st">  </span><span class="kw">group_by</span>(i) <span class="op">%&gt;%</span></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="st">  </span><span class="kw">summarize</span>(<span class="dt">x =</span> <span class="kw">mean</span>(x))</span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="co">#&gt; # A pibble:                         2 x 2</span></span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="co">#&gt; # Individual-level identifier (.i): i [2]</span></span>
<span id="cb17-17"><a href="#cb17-17"></a><span class="co">#&gt; # Gap (.d):                         1</span></span>
<span id="cb17-18"><a href="#cb17-18"></a><span class="co">#&gt;       i     x</span></span>
<span id="cb17-19"><a href="#cb17-19"></a><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span id="cb17-20"><a href="#cb17-20"></a><span class="co">#&gt; 1     1   1.5</span></span>
<span id="cb17-21"><a href="#cb17-21"></a><span class="co">#&gt; 2     2   3.5</span></span>
<span id="cb17-22"><a href="#cb17-22"></a></span>
<span id="cb17-23"><a href="#cb17-23"></a><span class="co"># So the between calculation should be</span></span>
<span id="cb17-24"><a href="#cb17-24"></a><span class="co"># 1.5 - 2.5 = -1 and 3.5 - 2.5 = 1 for the different groups:</span></span>
<span id="cb17-25"><a href="#cb17-25"></a>df<span class="op">$</span>between_x</span>
<span id="cb17-26"><a href="#cb17-26"></a><span class="co">#&gt; [1] -1 -1  1  1</span></span></code></pre></div>
</div>
<div id="within_i" class="section level2">
<h2>within_i()</h2>
<p><code>within_i()</code> performs the <em>within transformation</em>. In particular, it isolates the variation within <code>.i</code> groups in a variable <code>.var</code>, throwing out all variation between <code>.i</code> groups. The result averages out to <code>0</code> within combinations of <code>.i</code>.</p>
<p>The specific calculation that is performed is</p>
<p><span class="math display">\[within.i(x) = x_i - \bar{x}_i\]</span></p>
<p>where <span class="math inline">\(\bar{x}_i\)</span> is the mean of <code>x</code> within the <code>.i</code> groups.</p>
<p>The syntax for <code>within_i</code> is:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">within_i</span>(.var,</span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="dt">.df =</span> <span class="kw">get</span>(<span class="st">&quot;.&quot;</span>, <span class="dt">envir =</span> <span class="kw">parent.frame</span>()),</span>
<span id="cb18-3"><a href="#cb18-3"></a>  <span class="dt">.fcn =</span> <span class="cf">function</span>(x) <span class="kw">mean</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),</span>
<span id="cb18-4"><a href="#cb18-4"></a>  <span class="dt">.i =</span> <span class="ot">NULL</span>,</span>
<span id="cb18-5"><a href="#cb18-5"></a>  <span class="dt">.t =</span> <span class="ot">NULL</span>,</span>
<span id="cb18-6"><a href="#cb18-6"></a>  <span class="dt">uniqcheck =</span> <span class="ot">FALSE</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>)</span></code></pre></div>
<p>Where <code>.var</code> is the variable on which the transformation is performed, and <code>.df</code> is the data set. If the data set is being passed in via <code>%&gt;% mutate()</code> or similar, then <code>.df</code> will automatically pick it up and you don’t need to specify it. <code>.fcn</code> is the function applied to calculate the group values, i.e. <span class="math inline">\(.fcn(x) = \bar{x}\)</span>. The standard definition of the within transformation is for this to be the mean, but it has been left flexible.</p>
<p>The rest of the options include standard arguments related to declaring the panel structure of the data (<code>.i</code>, <code>.t</code>, <code>.uniqcheck</code>, see the “pibble” section above). <code>.d</code> is omitted because it is irrelevant to the calculation.</p>
<p>An example of the between transformation follows:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>),</span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>,</span>
<span id="cb19-4"><a href="#cb19-4"></a>  <span class="dt">.i =</span> i</span>
<span id="cb19-5"><a href="#cb19-5"></a>) <span class="op">%&gt;%</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">within_x =</span> <span class="kw">within_i</span>(x))</span>
<span id="cb19-7"><a href="#cb19-7"></a></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="co"># Notice that the mean within groups is...</span></span>
<span id="cb19-9"><a href="#cb19-9"></a>df <span class="op">%&gt;%</span></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="st">  </span><span class="kw">group_by</span>(i) <span class="op">%&gt;%</span></span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="st">  </span><span class="kw">summarize</span>(<span class="dt">x =</span> <span class="kw">mean</span>(x))</span>
<span id="cb19-12"><a href="#cb19-12"></a><span class="co">#&gt; # A pibble:                         2 x 2</span></span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="co">#&gt; # Individual-level identifier (.i): i [2]</span></span>
<span id="cb19-14"><a href="#cb19-14"></a><span class="co">#&gt; # Gap (.d):                         1</span></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="co">#&gt;       i     x</span></span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span id="cb19-17"><a href="#cb19-17"></a><span class="co">#&gt; 1     1   1.5</span></span>
<span id="cb19-18"><a href="#cb19-18"></a><span class="co">#&gt; 2     2   3.5</span></span>
<span id="cb19-19"><a href="#cb19-19"></a></span>
<span id="cb19-20"><a href="#cb19-20"></a><span class="co"># So the between calculation should be</span></span>
<span id="cb19-21"><a href="#cb19-21"></a><span class="co"># 1 - 1.5 = -.5 and 2 - 1.5 = .5 for individual 1</span></span>
<span id="cb19-22"><a href="#cb19-22"></a><span class="co"># and 3 - 3.5 = -.5 and 4 - 3.5 = .5 individual 2:</span></span>
<span id="cb19-23"><a href="#cb19-23"></a>df<span class="op">$</span>within_x</span>
<span id="cb19-24"><a href="#cb19-24"></a><span class="co">#&gt; [1] -0.5  0.5 -0.5  0.5</span></span></code></pre></div>
</div>
<div id="mode_order" class="section level2">
<h2>mode_order()</h2>
<p>R does not have a base function for calculating the mode of a vector. But <code>fixed_force()</code> wanted one, and so here we are. This function has been exported for general use in case it comes in handy elsewhere.</p>
<p>In particular, <code>mode_order()</code> calculates the mode of a vector and, if there are ties between two different values, selects the one that comes earlier in the original vector order.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co"># 2 appears twice while everything else appears once; 2 is the mode.</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="ot">NA</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="kw">mode_order</span>(x)</span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co">#&gt; [1] 2</span></span>
<span id="cb20-5"><a href="#cb20-5"></a></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="co"># 1 or 2 could be the mode.</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co"># Ties are broken by order in the vector.</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="kw">mode_order</span>(x)</span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="co">#&gt; [1] 2</span></span></code></pre></div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
