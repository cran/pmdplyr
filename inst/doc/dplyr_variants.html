<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Nick Huntington-Klein, Philip Khor" />

<meta name="date" content="2020-03-09" />

<title>pmdplyr: dplyr Variants</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">pmdplyr: dplyr Variants</h1>
<h4 class="author">Nick Huntington-Klein, Philip Khor</h4>
<h4 class="date">2020-03-09</h4>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">library</span>(pmdplyr)</a></code></pre></div>
<p>The <code>pmdplyr</code> package is an extension to <code>dplyr</code> designed for cleaning and managing panel and hierarchical data. It contains variations on the <code>dplyr::mutate()</code> and <code>dplyr::join()</code> functions that address common panel data needs, and contains functions for managing and cleaning panel data.</p>
<p>Unlike other panel data packages, functions in <code>pmdplyr</code> are all designed to work even if there is more than one observation per individual per period. This comes in handy if each individual is observed multiple times per period - for example, multiple classes per student per term; or if you have hierarchical data - for example, multiple companies per country.</p>
<p>There are three vignettes in total describing the contents of <code>pmdplyr</code>:</p>
<ol style="list-style-type: decimal">
<li><p>“pmdplyr”/“Get Started”, which describes the <code>pibble</code> panel data object type, and the <code>pmdplyr</code> tools for creating well-behaved ID and time variables <code>id_variable()</code> and <code>time_variable()</code>.</p></li>
<li><p><strong>CURRENT VIGNETTE</strong> “dplyr variants”, which that describes <code>pmdplyr</code> variations on <code>dplyr</code> functions <code>mutate()</code> (<code>mutate_cascade()</code> and <code>mutate_subset()</code>), <code>_join</code> (<code>inexact_join</code> and <code>safe_join()</code>), and <code>lag</code> (<code>tlag()</code>).</p></li>
<li><p>“Panel Tools”, which describes novel tools that <code>pmdplyr</code> provides for cleaning and manipulating panel data (<code>panel_fill()</code>, <code>panel_locf()</code>, <code>fixed_check()</code>, <code>fixed_force()</code>, <code>between_i()</code>, <code>within_i()</code>, <code>mode_order()</code>).</p></li>
</ol>
<hr />
<div id="joins" class="section level1">
<h1>Joins</h1>
<p><code>pmdplyr</code> offers a set of wrappers for the <code>dplyr::join()</code> functions.</p>
<div id="inexact_join" class="section level2">
<h2>inexact_join()</h2>
<p>The set of <code>inexact_join()</code> functions maps directly onto the set of <code>dplyr::join()</code> functions:</p>
<ul>
<li><strong>Mutating joins</strong>: <code>inexact_inner_join()</code>, <code>inexact_left_join()</code>, <code>inexact_right_join()</code>, <code>inexact_full_join()</code></li>
<li><strong>Filtering joins</strong>: <code>inexact_semi_join()</code>, and <code>inexact_anti_join()</code></li>
<li><strong>Nesting joins</strong>: <code>inexact_nest_join()</code></li>
</ul>
<p>Here we will focus specifically on <code>inexact_left_join()</code>. For the differences between the functions, see <code>dplyr::join()</code>.</p>
<p><code>join()</code> functions take two data sets and join them based on matching values of a set of shared variables.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">left_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="dt">v1 =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span></a>
<a class="sourceLine" id="cb2-5" title="5">)</a>
<a class="sourceLine" id="cb2-6" title="6">right_df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>),</a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="dt">v2 =</span> <span class="dv">7</span><span class="op">:</span><span class="dv">12</span></a>
<a class="sourceLine" id="cb2-10" title="10">)</a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="co"># It automatically detects that i and t are the shared variables</span></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co"># and finds two combinations of those in left_df that are also</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co"># in right_df: i = 1, t = 2, and i = 2, t = 2. So it brings the</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="co"># v2 values it can match up in to the joined data.</span></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co"># Other observations don&#39;t find a match</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="kw">left_join</span>(left_df, right_df)</a>
<a class="sourceLine" id="cb2-18" title="18"><span class="co">#&gt;   i t v1 v2</span></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="co">#&gt; 1 1 1  1 NA</span></a>
<a class="sourceLine" id="cb2-20" title="20"><span class="co">#&gt; 2 1 2  2  8</span></a>
<a class="sourceLine" id="cb2-21" title="21"><span class="co">#&gt; 3 1 3  3 NA</span></a>
<a class="sourceLine" id="cb2-22" title="22"><span class="co">#&gt; 4 2 1  4 NA</span></a>
<a class="sourceLine" id="cb2-23" title="23"><span class="co">#&gt; 5 2 2  5 11</span></a>
<a class="sourceLine" id="cb2-24" title="24"><span class="co">#&gt; 6 2 3  6 NA</span></a></code></pre></div>
<p>However, it is common (especially in a panel data context) to want to join two data frames where one of the variables does not line up exactly. For example, maybe we want those <code>t = 1</code> values in <code>left_df</code> to pick up the <code>t = 0</code> values in <code>right_df</code>.</p>
<p>We can do this, in a few different ways with an <code>inexact_join()</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">inexact_left_join</span>(x, y,</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">by =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="dt">copy =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="dt">suffix =</span> <span class="kw">c</span>(<span class="st">&quot;.x&quot;</span>, <span class="st">&quot;.y&quot;</span>),</a>
<a class="sourceLine" id="cb3-5" title="5">  ...,</a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="dt">var =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb3-7" title="7">  <span class="dt">jvar =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb3-8" title="8">  method,</a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="dt">exact =</span> <span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb3-10" title="10">)</a></code></pre></div>
<p>The first arguments: <code>x, y, by, copy, suffix, ...</code>, are standard arguments to be passed to <code>left_join()</code>. <code>x</code> and <code>y</code> are our left-hand and right-hand data sets, respectively. See <code>dplyr::left_join()</code> for the rest.</p>
<p>We’ve added on here <code>var, jvar, method</code>, and <code>exact</code>.</p>
<p><code>var</code> is the variable in the left-hand data set that you would like to match inexactly on, and <code>jvar</code> is the variable(s) in the right-hand data set that you would like to match inexactly on. It’s important that the names of these variables aren’t shared, because the resulting data set will show how <code>var</code> and <code>jvar</code> line up. So let’s prepare our data by renaming <code>t</code> in <code>right_df</code> to something else so it’s not <code>t</code> in both data sets.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1">right_df &lt;-<span class="st"> </span>right_df <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="st">  </span><span class="kw">rename</span>(<span class="dt">t_right =</span> t)</a></code></pre></div>
<p><code>method</code> determines <em>how</em> <code>var</code> and <code>jvar</code> will be matched up.</p>
<ul>
<li><code>method = &quot;last&quot;</code> matches <code>var</code> to the closest value of <code>jvar</code> that is <em>lower</em>, so those <code>t = 1</code> observations will get matched to <code>t_right = 0</code>, and <code>t = 3</code> will get matched to <code>t_right = 2</code> (meaning that <code>t_right = 2</code> will get matched to both <code>t = 2</code> and <code>t = 3</code>):</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">inexact_left_join</span>(left_df,</a>
<a class="sourceLine" id="cb5-2" title="2">  right_df,</a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="dt">var =</span> t, <span class="dt">jvar =</span> t_right,</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="dt">method =</span> <span class="st">&quot;last&quot;</span></a>
<a class="sourceLine" id="cb5-5" title="5">)</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">#&gt;   i t v1 t_right v2</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">#&gt; 1 1 1  1       0  7</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co">#&gt; 2 1 2  2       2  8</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="co">#&gt; 3 1 3  3       2  8</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co">#&gt; 4 2 1  4       0 10</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="co">#&gt; 5 2 2  5       2 11</span></a>
<a class="sourceLine" id="cb5-12" title="12"><span class="co">#&gt; 6 2 3  6       2 11</span></a></code></pre></div>
<ul>
<li><code>method = &quot;next&quot;</code> matches <code>var</code> to the closest value of <code>jvar</code> that is <em>higher</em>, so now <code>t = 1</code> will get matched to <code>t_right = 2</code>, and <code>t = 3</code> will get matched to <code>t_right = 4</code>:</li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">inexact_left_join</span>(left_df,</a>
<a class="sourceLine" id="cb6-2" title="2">  right_df,</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="dt">var =</span> t, <span class="dt">jvar =</span> t_right,</a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="dt">method =</span> <span class="st">&quot;next&quot;</span></a>
<a class="sourceLine" id="cb6-5" title="5">)</a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co">#&gt;   i t v1 t_right v2</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">#&gt; 1 1 1  1       2  8</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">#&gt; 2 1 2  2       2  8</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="co">#&gt; 3 1 3  3       4  9</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co">#&gt; 4 2 1  4       2 11</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="co">#&gt; 5 2 2  5       2 11</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="co">#&gt; 6 2 3  6       4 12</span></a></code></pre></div>
<ul>
<li><code>method = &quot;closest&quot;</code> will match <code>var</code> to the closest value of <code>jvar</code> in either direction. If there’s a tie, it will pick the lower value of <code>jvar</code>. So now <code>t = 1</code> will pick <code>t_right = 0</code> (out of a tie between <code>0</code> and <code>2</code>), and <code>t = 3</code> will match to <code>t = 2</code>:</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">inexact_left_join</span>(left_df,</a>
<a class="sourceLine" id="cb7-2" title="2">  right_df,</a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="dt">var =</span> t, <span class="dt">jvar =</span> t_right,</a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="dt">method =</span> <span class="st">&quot;closest&quot;</span></a>
<a class="sourceLine" id="cb7-5" title="5">)</a>
<a class="sourceLine" id="cb7-6" title="6"><span class="co">#&gt;   i t v1 t_right v2</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="co">#&gt; 1 1 1  1       0  7</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="co">#&gt; 2 1 2  2       2  8</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="co">#&gt; 3 1 3  3       2  8</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="co">#&gt; 4 2 1  4       0 10</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="co">#&gt; 5 2 2  5       2 11</span></a>
<a class="sourceLine" id="cb7-12" title="12"><span class="co">#&gt; 6 2 3  6       2 11</span></a></code></pre></div>
<ul>
<li>Finally, <code>method = &quot;between&quot;</code> is for matching <code>var</code> to a set of two <code>jvar</code>s that define the beginning and end of a <em>range</em>. Make sure that the ranges are non-overlapping within the joining variables, or else you will get strange results (specifically, it should join to the earliest-starting range). So now, given the way we define <code>t_bottom</code> and <code>t_top</code> below, <code>t = 1</code> should go in the range <code>t_bottom = 0, t_top = 2</code>, and <code>t = 2</code> and <code>t = 3</code> should both go in the range <code>t_bottom = 2, t_top = 4</code>.</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1">right_df &lt;-<span class="st"> </span>right_df <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="st">  </span><span class="kw">rename</span>(<span class="dt">t_bottom =</span> t_right) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">t_top =</span> t_bottom <span class="op">+</span><span class="st"> </span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">inexact_left_join</span>(left_df,</a>
<a class="sourceLine" id="cb8-6" title="6">  right_df,</a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="dt">var =</span> t, <span class="dt">jvar =</span> <span class="kw">c</span>(t_bottom, t_top),</a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="dt">method =</span> <span class="st">&quot;between&quot;</span></a>
<a class="sourceLine" id="cb8-9" title="9">)</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="co">#&gt;   i t v1 t_bottom v2 t_top</span></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="co">#&gt; 1 1 1  1        0  7     2</span></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="co">#&gt; 2 1 2  2        2  8     4</span></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="co">#&gt; 3 1 3  3        2  8     4</span></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="co">#&gt; 4 2 1  4        0 10     2</span></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="co">#&gt; 5 2 2  5        2 11     4</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="co">#&gt; 6 2 3  6        2 11     4</span></a></code></pre></div>
<p>So that leaves us with <code>exact</code>. <code>exact</code> determines whether or not an exact match is an acceptable match, and interprets <code>&quot;last&quot;</code> as “this value or earlier” and <code>&quot;next&quot;</code> as “this value or later”. Generally, for joining purposes, you’ll want this to be <code>TRUE</code>. But perhaps you don’t! Maybe you want “earlier” or “later” only to get something like “the most recent previous value” for <code>method = &quot;last&quot;</code>. In that case, set this to <code>FALSE</code>.</p>
<p>In the case of <code>method = &quot;between&quot;</code>, it’s especially important to keep track of <code>exact</code> because it’s common for one range to start at the exact endpoint of another. If the end of one range is the exact start of another, <code>exact = c(TRUE, FALSE)</code> or <code>exact = c(FALSE, TRUE)</code> is recommended to avoid overlaps. Defaults to <code>exact = c(TRUE, FALSE)</code>.</p>
</div>
<div id="safe_join" class="section level2">
<h2>safe_join()</h2>
<p>When joining two data sets <code>x</code> and <code>y</code> on a set of shared variables <code>by</code>, there are four ways in which they can be matched: one-to-many (<code>by</code> uniquely identifies rows in <code>x</code> but not <code>y</code>, so each observation in <code>x</code> will be matched to several in <code>y</code>), many-to-one (<code>by</code> uniquely identifies rows in <code>y</code> but not <code>x</code>, so each observation in <code>y</code> will be matched to several in <code>x</code>), one-to-one (<code>by</code> uniquely identifies rows in both <code>x</code> and <code>y</code>, so each observation in <code>x</code> will be matched to exactly one in <code>y</code>), and many-to-many (<code>by</code> does not uniquely identify rows in either <code>x</code> or <code>y</code>).</p>
<p>Unfortunately, when you perform a <code>join()</code> or <code>inexact_join()</code>, it doesn’t tell you which of those you’ve just done! This can be especially problematic if you’ve accidentally done a many-to-many join, since many-to-many join often leads to unexpected results.</p>
<p><code>safe_join()</code> is a wrapper for all <code>join()</code> and <code>inexact_join()</code> functions which tells you whether you are, in fact, doing the join you expect to be doing, and returns an error if you’re not.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">safe_join</span>(x, y,</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="dt">expect =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="dt">join =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb9-4" title="4">  ...</a>
<a class="sourceLine" id="cb9-5" title="5">)</a></code></pre></div>
<p><code>x</code>, <code>y</code>, and <code>...</code> are the standard <code>join()</code>/<code>inexact_join()</code> arguments that you would normally use. See <code>help(join, package = &quot;dplyr&quot;)</code> or the <code>inexact_join</code> section above to see what arguments might go in <code>...</code> to pass through to those functions, such as <code>suffix</code> or <code>var</code>.</p>
<p><code>expect</code> is a character variable where you specify the type of join you <em>think</em> you’re about to do. You can specify this either as one-to-many / many-to-one / one-to-one directly, or you can specify which of the two data sets (<code>x</code> or <code>y</code>) you think should be uniquely identified by the joining variables.</p>
<ul>
<li><code>expect = &quot;1:1&quot;</code> or <code>expect = c(&quot;x&quot;, &quot;y&quot;)</code> or <code>expect = &quot;xy&quot;</code> indicates that you anticipate to join one-to-one.</li>
<li><code>expect = &quot;m:1&quot;</code> or expect = “y”` indicates that you expect to join many-to-one.</li>
<li><code>expect = &quot;1:m&quot;</code> or <code>&quot;expect = &quot;x&quot;</code> indicates that you expect to join one-to-many.</li>
<li><code>expect = &quot;no m:m&quot;</code> indicates that you don’t care whether you’re one-to-one, one-to-many, or many-to-one, as long as you’re not many-to-many.</li>
<li>There is no <code>expect</code> option that allows you to run a many-to-many join.</li>
</ul>
<p><code>safe_join()</code> will return an error if your data do not match your <code>expect</code> selection.</p>
<p>If your data <em>does</em> match your <code>expect</code> option, then it will look to your <code>join</code>. <code>join</code> is the function for the <code>join</code> or <code>inexact_join</code> you’d like to run, for example <code>join = inexact_left_join</code>.</p>
<p>If run without a <code>join</code> specified, <code>safe_join()</code> will return <code>TRUE</code> if you’re good to go. If run with a <code>join</code> specified, then instead <code>safe_join()</code> will pass your data on to the function and actually run the join for you.</p>
<p>There is little reason to run any <code>join()</code> or <code>inexact_join()</code> without going through <code>safe_join()</code>. It will help you avoid some nasty surprises!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1"><span class="co"># left is panel data and i does not uniquely identify observations</span></a>
<a class="sourceLine" id="cb10-2" title="2">left &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="dt">a =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb10-6" title="6">)</a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co"># right is individual-level data uniquely identified by i</span></a>
<a class="sourceLine" id="cb10-8" title="8">right &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb10-10" title="10">  <span class="dt">b =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb10-11" title="11">)</a>
<a class="sourceLine" id="cb10-12" title="12"></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="co"># I think that I can do a one-to-one merge on i</span></a>
<a class="sourceLine" id="cb10-14" title="14"><span class="co"># Forgetting that left is identified by i and t together</span></a>
<a class="sourceLine" id="cb10-15" title="15"><span class="co"># So, this produces an error</span></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="kw">try</span>(</a>
<a class="sourceLine" id="cb10-17" title="17">  <span class="kw">safe_join</span>(left, right, <span class="dt">expect =</span> <span class="st">&quot;1:1&quot;</span>, <span class="dt">join =</span> left_join)</a>
<a class="sourceLine" id="cb10-18" title="18">)</a>
<a class="sourceLine" id="cb10-19" title="19"><span class="co">#&gt; Error in safe_join(left, right, expect = &quot;1:1&quot;, join = left_join) : </span></a>
<a class="sourceLine" id="cb10-20" title="20"><span class="co">#&gt;   The left-hand data set x is not uniquely identified by the joining variable i.</span></a>
<a class="sourceLine" id="cb10-21" title="21"></a>
<a class="sourceLine" id="cb10-22" title="22"><span class="co"># If I realize I&#39;m doing a many-to-one merge, that is correct,</span></a>
<a class="sourceLine" id="cb10-23" title="23"><span class="co"># so safe_join will return TRUE if we don&#39;t specify a join</span></a>
<a class="sourceLine" id="cb10-24" title="24"><span class="co"># or perform the join for us if we do</span></a>
<a class="sourceLine" id="cb10-25" title="25"><span class="kw">safe_join</span>(left, right, <span class="dt">expect =</span> <span class="st">&quot;m:1&quot;</span>)</a>
<a class="sourceLine" id="cb10-26" title="26"><span class="co">#&gt; [1] TRUE</span></a>
<a class="sourceLine" id="cb10-27" title="27"><span class="kw">safe_join</span>(left, right, <span class="dt">expect =</span> <span class="st">&quot;m:1&quot;</span>, <span class="dt">join =</span> left_join)</a>
<a class="sourceLine" id="cb10-28" title="28"><span class="co">#&gt;   i t a b</span></a>
<a class="sourceLine" id="cb10-29" title="29"><span class="co">#&gt; 1 1 1 1 1</span></a>
<a class="sourceLine" id="cb10-30" title="30"><span class="co">#&gt; 2 1 2 2 1</span></a>
<a class="sourceLine" id="cb10-31" title="31"><span class="co">#&gt; 3 2 1 3 2</span></a>
<a class="sourceLine" id="cb10-32" title="32"><span class="co">#&gt; 4 2 2 4 2</span></a></code></pre></div>
<hr />
</div>
</div>
<div id="mutate-variations" class="section level1">
<h1>Mutate Variations</h1>
<p><code>pmdplyr</code> adds several new versions of <code>dplyr::mutate()</code> that help with some common panel-data manipulation needs.</p>
<div id="mutate_subset" class="section level2">
<h2>mutate_subset()</h2>
<p><code>mutate_subset()</code> is a function that performs a <code>dplyr::summarize()</code> command on a subset (<code>.filter</code>) of your data, and then takes the result and applies it to all observations in your data (or all observations within group, if grouped).</p>
<p>The most common use of this is to <em>partially widen</em> your data. Panel data can be stored in “wide” format, where there is one row per individual and, for each variable, one column per time period, or the more common (and assumed in <code>pmdplyr</code>) “long” format where there is one (or possibly more than one) row per individual/time period.</p>
<p>The benefit of wide data is that it makes it very easy to compare variables across wide stretches of time. How much has asset <code>1</code> increased in value from the beginning of the sample? Easy in wide data, a little trickier in long (although it could be done with a <code>tlag()</code>, see tlag() section).</p>
<p>If you only have a few such comparisons to make, <code>mutate_subset()</code> lets you make them without fully widening the data. Just make a “value at the beginning of the sample” variable, if that’s all you need, without having to bother fully widening.</p>
<p>Another common use is to make specific comparisons within groups. If I want to know how your earnings compare to the average earnings in your state, I can just do a <code>within_i()</code> calculation (see Additional Calculations section). But what if I want to know how your earnings compare to the average earnings <em>of college graduates</em> in your state? That’s harder. But <code>mutate_subset()</code> makes it easy.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">mutate_subset</span>(.df,</a>
<a class="sourceLine" id="cb11-2" title="2">  ...,</a>
<a class="sourceLine" id="cb11-3" title="3">  .filter,</a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="dt">.group_i =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb11-5" title="5">  <span class="dt">.i =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="dt">.t =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb11-7" title="7">  <span class="dt">.d =</span> <span class="ot">NA</span>,</a>
<a class="sourceLine" id="cb11-8" title="8">  <span class="dt">.uniqcheck =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb11-9" title="9">  <span class="dt">.setpanel =</span> <span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb11-10" title="10">)</a></code></pre></div>
<p>where <code>.df</code> is the data set being mutated and <code>...</code> is a set of name-value pairs of expressions in the style of <code>dplyr::mutate</code>. Note that, since the idea here is to get a summary measure from a filtered group, expressions should be written such that they would be valid arguments in <code>dplyr::summarize()</code>.</p>
<p><code>.filter</code> is a logical condition that describes the observations that you want to perform the <code>...</code> calculations on.</p>
<p>Let’s perform the analysis we described above, comparing an individual’s earnings to the average earnings of college graduates in their state:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1">df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="dt">state =</span> <span class="kw">c</span>(<span class="st">&quot;CA&quot;</span>, <span class="st">&quot;CA&quot;</span>, <span class="st">&quot;CA&quot;</span>, <span class="st">&quot;NV&quot;</span>, <span class="st">&quot;NV&quot;</span>, <span class="st">&quot;NV&quot;</span>),</a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="dt">college =</span> <span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="dt">earn =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb12-5" title="5">  <span class="dt">.i =</span> state</a>
<a class="sourceLine" id="cb12-6" title="6">)</a>
<a class="sourceLine" id="cb12-7" title="7"></a>
<a class="sourceLine" id="cb12-8" title="8">df <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="st">  </span><span class="co"># Calculate average earnings of college grads</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="st">  </span><span class="kw">mutate_subset</span>(<span class="dt">college_earnings =</span> <span class="kw">mean</span>(earn), <span class="dt">.filter =</span> college <span class="op">==</span><span class="st"> </span><span class="ot">TRUE</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="st">  </span><span class="co"># And compare to our own earnings</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">earnings_vs_college =</span> earn <span class="op">-</span><span class="st"> </span>college_earnings)</a>
<a class="sourceLine" id="cb12-13" title="13"><span class="co">#&gt; # A tibble: 6 x 5</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="co">#&gt;   state college  earn college_earnings earnings_vs_college</span></a>
<a class="sourceLine" id="cb12-15" title="15"><span class="co">#&gt;   &lt;chr&gt; &lt;lgl&gt;   &lt;dbl&gt;            &lt;dbl&gt;               &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="co">#&gt; 1 CA    TRUE        1              1.5                -0.5</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="co">#&gt; 2 CA    TRUE        2              1.5                 0.5</span></a>
<a class="sourceLine" id="cb12-18" title="18"><span class="co">#&gt; 3 CA    FALSE       3              1.5                 1.5</span></a>
<a class="sourceLine" id="cb12-19" title="19"><span class="co">#&gt; 4 NV    TRUE        2              2                   0  </span></a>
<a class="sourceLine" id="cb12-20" title="20"><span class="co">#&gt; 5 NV    FALSE       3              2                   1  </span></a>
<a class="sourceLine" id="cb12-21" title="21"><span class="co">#&gt; 6 NV    FALSE       2              2                   0</span></a></code></pre></div>
<p>The rest of the options include <code>.group_i</code> (by default, if <code>.i</code> can be found, analysis will be performed within-individual. Set <code>.group_i = FALSE</code> to ignore this), and standard arguments related to declaring the panel structure of the data (<code>.i</code>, <code>.t</code>, <code>.d</code>, <code>.uniqcheck</code>, see the “pibble” section above). The <code>.d = NA</code> will become <code>.d = 1</code> if either <code>.i</code> or <code>.t</code> are declared. <code>.setpanel</code> ensures that if you declare the panel structure in the <code>mutate_subset()</code> function, it will be maintained in the object you get back.</p>
</div>
<div id="mutate_cascade" class="section level2">
<h2>mutate_cascade()</h2>
<p><code>mutate_cascade()</code> performs <code>dplyr::mutate()</code> on a data set one time period at a time, in order, allowing the mutate from each time period to finish before moving on to the next one. The changes “cascade down” through time. This can be handy if your <code>mutate()</code> command makes reference to earlier time periods using (usually) <code>tlag()</code> (see below) and you want changes in one period to be passed down to the next.</p>
<p>In effect, you can think of <code>mutate_cascade()</code> as behaving much like <code>cumsum()</code>, <code>cumprod()</code>, <code>cummax()</code> or <code>cummin()</code>, except that it (1) respects the panel structure of the data, (2) works when you have multiple observations per <code>.i</code>/<code>.t</code>, (3) is much more flexible, and (4) is much slower.</p>
<p>As of this writing <code>mutate_cascade()</code> is pretty darn slow (after all, if you have T time periods, you’re running T separate <code>mutate</code> commands in a loop!), so be careful in using it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">mutate_cascade</span>(.df,</a>
<a class="sourceLine" id="cb13-2" title="2">  ...,</a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="dt">.skip =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="dt">.backwards =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb13-5" title="5">  <span class="dt">.group_i =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb13-6" title="6">  <span class="dt">.i =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb13-7" title="7">  <span class="dt">.t =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb13-8" title="8">  <span class="dt">.d =</span> <span class="ot">NA</span>,</a>
<a class="sourceLine" id="cb13-9" title="9">  <span class="dt">.uniqcheck =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb13-10" title="10">  <span class="dt">.setpanel =</span> <span class="ot">TRUE</span></a>
<a class="sourceLine" id="cb13-11" title="11">)</a></code></pre></div>
<p>where <code>.df</code> is the data set being mutated, and <code>...</code> is the list of expressions to be passed to <code>dplyr::mutate()</code>.</p>
<p><code>.skip</code> instructs <code>mutate_cascade()</code> to skip over the first time period within the group (or last time period if <code>backwards = TRUE</code>). This should usually be set to <code>TRUE</code>, since most usages of <code>mutate_cascade()</code> involve a <code>tlag()</code>, and the <code>tlag()</code> of something in the first time period is usually <code>NA</code>. Then, you’ve filled in that first-period <code>NA</code> - now the <code>tlag()</code> in period 2 is NA as well, and it will cascade down to make your whole data set <code>NA</code>. If you set <code>.skip = FALSE</code>, you should have some way in <code>...</code> of handling <code>NA</code>s (which you may want to do anyway in case there are <code>NA</code>s elsewhere in your data).</p>
<p><code>.backwards</code>, unsurprisingly, tells <code>mutate_cascade()</code> to start with the last time period and work backwards.</p>
<p>Let’s do a very simple example and use <code>mutate_cascade()</code> to build a present discounted value. We have an asset with a <code>payout</code> each period, and we have a discount factor <code>.95</code>. We can build a present discounted value <code>PDV</code> by taking the <code>PDV</code> in the next period, multiplying it by <code>.95</code>, and adding on the current <code>payout</code>. But we need to calculate <code>PDV</code> one period at a time, so that we can use each period’s calculation to calculate the previous one.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1">df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>),</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="dt">payout =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>),</a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="dt">.t =</span> t</a>
<a class="sourceLine" id="cb14-5" title="5">) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">PDV =</span> payout) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="st">  </span><span class="kw">mutate_cascade</span>(<span class="dt">PDV =</span> payout <span class="op">+</span><span class="st"> </span><span class="fl">.95</span> <span class="op">*</span><span class="st"> </span><span class="kw">tlag</span>(PDV, <span class="dt">.n =</span> <span class="dv">-1</span>), <span class="dt">.backwards =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9">df</a>
<a class="sourceLine" id="cb14-10" title="10"><span class="co">#&gt; # A tibble: 5 x 3</span></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="co">#&gt;       t payout   PDV</span></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="co">#&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="co">#&gt; 1     1      3 13.6 </span></a>
<a class="sourceLine" id="cb14-14" title="14"><span class="co">#&gt; 2     2      4 11.1 </span></a>
<a class="sourceLine" id="cb14-15" title="15"><span class="co">#&gt; 3     3      2  7.51</span></a>
<a class="sourceLine" id="cb14-16" title="16"><span class="co">#&gt; 4     4      2  5.8 </span></a>
<a class="sourceLine" id="cb14-17" title="17"><span class="co">#&gt; 5     5      4  4</span></a></code></pre></div>
<p>As expected, the <code>PDV</code> in period <code>5</code> is just the payout: <code>4</code>. In period <code>4</code> it’s <code>2 + .95*4 = 5.8</code>. Then in period <code>3</code> it’s <code>2 + .95*5.8 = 7.51</code>, and so on.</p>
<p>The rest of the options include <code>.group_i</code> (by default, if <code>.i</code> can be found, analysis will be performed within-individual. Set <code>.group_i = FALSE</code> to ignore this), and standard arguments related to declaring the panel structure of the data (<code>.i</code>, <code>.t</code>, <code>.d</code>, <code>.uniqcheck</code>, see the “pibble” section above). The <code>.d = NA</code> will become <code>.d = 1</code> if either <code>.i</code> or <code>.t</code> are declared. <code>.setpanel</code> ensures that if you declare the panel structure in the <code>mutaet_cascade()</code> function, it will be maintained in the object you get back.</p>
<hr />
</div>
</div>
<div id="tlag" class="section level1">
<h1>tlag()</h1>
<p><code>tlag()</code> is a function that lags a variable in time. It respects the panel structure of the data, works with multiple observations per combination of <code>.i</code>/<code>.t</code>, and, unlike <code>plm::lag()</code>, doesn’t run into masking problems by sharing a name with <code>dplyr::lag()</code>. Do remember that <code>dplyr::lag()</code> does not lag data in time, it lags data in the order of the data set.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">tlag</span>(.var,</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">.df =</span> <span class="kw">get</span>(<span class="st">&quot;.&quot;</span>, <span class="dt">envir =</span> <span class="kw">parent.frame</span>()),</a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="dt">.n =</span> <span class="dv">1</span>,</a>
<a class="sourceLine" id="cb15-4" title="4">  <span class="dt">.default =</span> <span class="ot">NA</span>,</a>
<a class="sourceLine" id="cb15-5" title="5">  <span class="dt">.quick =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="dt">.resolve =</span> <span class="st">&quot;error&quot;</span>,</a>
<a class="sourceLine" id="cb15-7" title="7">  <span class="dt">.group_i =</span> <span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb15-8" title="8">  <span class="dt">.i =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb15-9" title="9">  <span class="dt">.t =</span> <span class="ot">NULL</span>,</a>
<a class="sourceLine" id="cb15-10" title="10">  <span class="dt">.d =</span> <span class="ot">NA</span>,</a>
<a class="sourceLine" id="cb15-11" title="11">  <span class="dt">.uniqcheck =</span> <span class="ot">FALSE</span></a>
<a class="sourceLine" id="cb15-12" title="12">)</a></code></pre></div>
<p>where <code>.var</code> is the variable being lagged, , and <code>.df</code> is the data set that variable lives in. If the data set is being passed in via <code>%&gt;% mutate()</code> or similar, then <code>.df</code> will automatically pick it up and you don’t need to specify it.</p>
<p><code>.n</code> is the number of periods to lag. Negative values of <code>.n</code> imply a lead instead of a lag (as in the example in <code>mutate_cascade()</code> in the Mutate Variations section). There’s not a separate <code>tlead()</code> function.</p>
<p><code>.default</code> is the value to use if a lag does not exist. By default, this is <code>NA</code>. So if you have data in periods <code>1</code> and <code>3</code> but not <code>2</code>, then the <code>tlag</code> in the third period will produce <code>NA</code>.</p>
<p><code>.quick</code> is a setting you can use if your data is very nicely structured, with rows uniquely identified by <code>.i</code>/<code>.t</code> and either no gaps between time periods or <code>.d = 0</code>. <code>tlag()</code> will run more quickly with <code>.quick = TRUE</code>, but will produce incorrect results if these conditions are not met.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" title="1">df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>),</a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>,</a>
<a class="sourceLine" id="cb16-5" title="5">  <span class="dt">.i =</span> i,</a>
<a class="sourceLine" id="cb16-6" title="6">  <span class="dt">.t =</span> t</a>
<a class="sourceLine" id="cb16-7" title="7">) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="st">  </span><span class="co"># A lag and a lead, filling in the lead with 0 instead of NA</span></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="st">  </span><span class="kw">mutate</span>(</a>
<a class="sourceLine" id="cb16-10" title="10">    <span class="dt">x_lag =</span> <span class="kw">tlag</span>(x),</a>
<a class="sourceLine" id="cb16-11" title="11">    <span class="dt">x_lead =</span> <span class="kw">tlag</span>(x, <span class="dt">.n =</span> <span class="dv">-1</span>, <span class="dt">.default =</span> <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb16-12" title="12">    <span class="co"># Our data satisfies the .quick conditions so we can</span></a>
<a class="sourceLine" id="cb16-13" title="13">    <span class="co"># do that for a little extra speed</span></a>
<a class="sourceLine" id="cb16-14" title="14">    <span class="dt">x_quicklag =</span> <span class="kw">tlag</span>(x, <span class="dt">.quick =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb16-15" title="15">  )</a>
<a class="sourceLine" id="cb16-16" title="16"></a>
<a class="sourceLine" id="cb16-17" title="17">df</a>
<a class="sourceLine" id="cb16-18" title="18"><span class="co">#&gt; # A pibble:                         6 x 6</span></a>
<a class="sourceLine" id="cb16-19" title="19"><span class="co">#&gt; # Individual-level identifier (.i): i [2]</span></a>
<a class="sourceLine" id="cb16-20" title="20"><span class="co">#&gt; # Time variable (.t):               t [3]</span></a>
<a class="sourceLine" id="cb16-21" title="21"><span class="co">#&gt; # Gap (.d):                         1</span></a>
<a class="sourceLine" id="cb16-22" title="22"><span class="co">#&gt;       i     t     x x_lag x_lead x_quicklag</span></a>
<a class="sourceLine" id="cb16-23" title="23"><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;      &lt;int&gt;</span></a>
<a class="sourceLine" id="cb16-24" title="24"><span class="co">#&gt; 1     1     1     1    NA      2         NA</span></a>
<a class="sourceLine" id="cb16-25" title="25"><span class="co">#&gt; 2     1     2     2     1      3          1</span></a>
<a class="sourceLine" id="cb16-26" title="26"><span class="co">#&gt; 3     1     3     3     2      0          2</span></a>
<a class="sourceLine" id="cb16-27" title="27"><span class="co">#&gt; 4     2     1     4    NA      5         NA</span></a>
<a class="sourceLine" id="cb16-28" title="28"><span class="co">#&gt; 5     2     2     5     4      6          4</span></a>
<a class="sourceLine" id="cb16-29" title="29"><span class="co">#&gt; 6     2     3     6     5      0          5</span></a></code></pre></div>
<p>If <code>.var</code> is not constant within combinations of <code>.i</code> and <code>.t</code> we have a problem! Which value do we choose to use for the purpose of filling in other observations? <code>.resolve</code> makes this choice. By default, there will be an “error” if values of <code>.var</code> are inconsistent within <code>.i</code> and <code>.t</code>. Or, set <code>.resolve</code> to a summary function like <code>.resolve = mean</code> or <code>.resolve = function(x) mean(x, na.rm = TRUE)</code> to resolve inconsistencies before filling in.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" title="1">df &lt;-<span class="st"> </span><span class="kw">pibble</span>(</a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="dt">i =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb17-3" title="3">  <span class="dt">t =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb17-4" title="4">  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">6</span>,</a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="dt">.i =</span> i,</a>
<a class="sourceLine" id="cb17-6" title="6">  <span class="dt">.t =</span> t</a>
<a class="sourceLine" id="cb17-7" title="7">) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">x_lag =</span> <span class="kw">tlag</span>(x, <span class="dt">.resolve =</span> mean))</a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10">df</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="co">#&gt; # A pibble:                         6 x 4</span></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="co">#&gt; # Individual-level identifier (.i): i [2]</span></a>
<a class="sourceLine" id="cb17-13" title="13"><span class="co">#&gt; # Time variable (.t):               t [2]</span></a>
<a class="sourceLine" id="cb17-14" title="14"><span class="co">#&gt; # Gap (.d):                         1</span></a>
<a class="sourceLine" id="cb17-15" title="15"><span class="co">#&gt;       i     t     x x_lag</span></a>
<a class="sourceLine" id="cb17-16" title="16"><span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;</span></a>
<a class="sourceLine" id="cb17-17" title="17"><span class="co">#&gt; 1     1     1     1  NA  </span></a>
<a class="sourceLine" id="cb17-18" title="18"><span class="co">#&gt; 2     1     1     2  NA  </span></a>
<a class="sourceLine" id="cb17-19" title="19"><span class="co">#&gt; 3     1     2     3   1.5</span></a>
<a class="sourceLine" id="cb17-20" title="20"><span class="co">#&gt; 4     2     1     4  NA  </span></a>
<a class="sourceLine" id="cb17-21" title="21"><span class="co">#&gt; 5     2     1     5  NA  </span></a>
<a class="sourceLine" id="cb17-22" title="22"><span class="co">#&gt; 6     2     2     6   4.5</span></a></code></pre></div>
<p>The rest of the options include <code>.group_i</code> (by default, if <code>.i</code> can be found, lags will be performed within-individual. Set <code>.group_i = FALSE</code> to ignore this), and standard arguments related to declaring the panel structure of the data (<code>.i</code>, <code>.t</code>, <code>.d</code>, <code>.uniqcheck</code>, see the “pibble” section above). The <code>.d = NA</code> will become <code>.d = 1</code> if either <code>.i</code> or <code>.t</code> are declared.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
